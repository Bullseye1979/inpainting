<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>In-/Outpainting Tool</title>
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        font-size: 14px;
        color-scheme: dark;
      }
      body {
        margin: 0;
        padding: 0.75rem;
        background: #0b0b0b;
        color: #eee;
        display: flex;
        justify-content: center;
      }
      .app {
        width: 100%;
        max-width: 720px;
      }
      h1 {
        margin: 0 0 0.75rem 0;
        font-size: 1.1rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .canvas-area {
        position: relative;
        border: 1px solid #333;
        border-radius: 8px;
        background: radial-gradient(
          circle at top,
          #222 0,
          #111 55%,
          #0a0a0a 100%
        );
        overflow: hidden;
      }
      .canvas-inner {
        position: relative;
        width: 100%;
      }
      canvas {
        display: block;
        width: 100%;
        height: auto;
      }
      #maskCanvas,
      #cursorCanvas {
        position: absolute;
        left: 0;
        top: 0;
      }
      #maskCanvas {
        pointer-events: auto;
        opacity: 0.6;
      }
      #cursorCanvas {
        pointer-events: none;
      }

      .overlay-hint {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 0.75rem;
        font-size: 0.85rem;
        color: #bbb;
        pointer-events: none;
        backdrop-filter: blur(2px);
      }
      .overlay-hint span {
        opacity: 0.9;
        margin: 0.1rem 0;
      }
      .overlay-hint strong {
        color: #0af;
        font-weight: 500;
      }
      .overlay-hint.hidden {
        display: none;
      }

      #controls {
        margin-top: 0.6rem;
        display: none;
        flex-direction: column;
        gap: 0.45rem;
      }

      #prompt {
        width: 100%;
        min-height: 52px;
        max-height: 100px;
        resize: vertical;
        font-size: 0.9rem;
        padding: 0.4rem 0.45rem;
        border-radius: 6px;
        border: 1px solid #333;
        background: #161616;
        color: #eee;
        box-sizing: border-box;
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: space-between;
      }

      .left-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex: 1 1 auto;
        flex-wrap: wrap;
      }

      .slider-wrap {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.8rem;
        color: #aaa;
        white-space: nowrap;
        padding: 0.2rem 0.35rem;
        border-radius: 999px;
        background: #141414;
        border: 1px solid #2b2b2b;
      }
      .slider-wrap span {
        font-size: 0.95rem;
      }
      #brushSize {
        width: 110px;
      }

      .engine-wrap {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.8rem;
        color: #aaa;
        white-space: nowrap;
        padding: 0.2rem 0.35rem;
        border-radius: 999px;
        background: #141414;
        border: 1px solid #2b2b2b;
      }
      #engineSelect {
        font-size: 0.8rem;
        background: black;
        color: #eee;
        border-radius: 999px;
        border: 1px solid #333;
        padding: 0.15rem 0.5rem;
      }

      #status {
        font-size: 0.78rem;
        color: #c0c0c0;
      }

      #publishNotice {
        display: none;
        font-size: 0.75rem;
        padding: 0.12rem 0.45rem;
        border-radius: 999px;
        border: 1px solid rgba(0, 170, 255, 0.35);
        background: rgba(0, 170, 255, 0.09);
        color: #9ddcff;
        white-space: nowrap;
      }

      #apiError {
        display: none;
        margin-top: 0.25rem;
        padding: 0.45rem 0.55rem;
        border-radius: 10px;
        border: 1px solid rgba(255, 80, 80, 0.45);
        background: rgba(255, 80, 80, 0.10);
        color: #ffd2d2;
        font-size: 0.82rem;
        line-height: 1.25;
      }

      .buttons {
        display: flex;
        gap: 0.3rem;
      }
      button {
        padding: 0.3rem 0.55rem;
        border-radius: 999px;
        border: none;
        cursor: pointer;
        background: linear-gradient(135deg, #0af, #6cf);
        color: #000;
        font-size: 0.9rem;
        font-weight: 600;
      }
      button.secondary {
        background: #1a1a1a;
        color: #eee;
        border: 1px solid #333;
        font-weight: 500;
      }
      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .hint-card {
        margin-top: 0.55rem;
        border: 1px solid #232323;
        background: #0f0f0f;
        border-radius: 10px;
        padding: 0.55rem 0.6rem;
      }
      .hint-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.35rem;
      }
      .hint-title {
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #f5f5f5;
      }
      .hint-badge {
        font-size: 0.7rem;
        padding: 0.1rem 0.4rem;
        border-radius: 999px;
        background: rgba(0, 170, 255, 0.09);
        color: #9ddcff;
        border: 1px solid rgba(0, 170, 255, 0.35);
      }
      .hint-list {
        list-style: none;
        padding: 0;
        margin: 0.2rem 0 0;
      }
      .hint-list li {
        display: flex;
        align-items: flex-start;
        gap: 0.35rem;
        margin: 0.15rem 0;
        line-height: 1.25;
      }
      .hint-icon {
        font-size: 0.85rem;
        margin-top: 0.03rem;
      }
      .hint-text-strong {
        font-weight: 500;
        color: #f0f0f0;
      }
      .hint-sub {
        font-size: 0.74rem;
        color: #9a9a9a;
      }
    </style>
  </head>

  <body>
    <div class="app">
      <h1>In-/Outpainting Tool</h1>

      <div id="canvasArea" class="canvas-area">
        <div class="canvas-inner">
          <canvas id="imageCanvas"></canvas>
          <canvas id="maskCanvas"></canvas>
          <canvas id="cursorCanvas"></canvas>
        </div>
        <div id="overlayHint" class="overlay-hint">
          <span class="hint-text-strong">How to start</span>
          <span>Open the page with a URL parameter, for example:</span>
          <span><strong>?src=https://‚Ä¶/image.png</strong></span>
          <span>Once the image is visible, you can paint your mask.</span>
          <span>Inpainting is only available for allowed image origins.</span>
        </div>
      </div>

      <div id="controls">
        <textarea
          id="prompt"
          placeholder="e.g. 'replace the background with a sunset beach scene'"
        ></textarea>

        <div class="control-row">
          <div class="left-controls">
            <div class="slider-wrap">
              <span title="Brush size">üñå</span>
              <input type="range" id="brushSize" min="5" max="80" value="25" />
              <span id="brushSizeLabel">25 px</span>
            </div>

            <div class="engine-wrap">
              <span title="Image engine">‚öô</span>
              <select id="engineSelect"></select>
            </div>

            <span id="status"></span>
            <span id="publishNotice">‚úÖ Sent</span>
          </div>

          <div class="buttons">
            <button id="editBtn" title="Run in-/outpainting">‚úèÔ∏è</button>
            <button
              id="modeBtn"
              class="secondary"
              title="Mask mode: reveal areas to be edited"
            >
              ‚óé
            </button>
            <button
              id="outBtn"
              class="secondary"
              title="Image mode: inpainting only inside the original image"
            >
              ‚ñ£
            </button>
            <button
              id="viewBtn"
              class="secondary"
              title="View mode: hide/show the mask overlay"
            >
              üï∂
            </button>
            <button
              id="resetBtn"
              class="secondary"
              title="Reset back to the original image"
            >
              ‚ü≥
            </button>
            <button
              id="downloadBtn"
              class="secondary"
              title="Download the current image as PNG"
            >
              ‚¨á
            </button>
            <button
              id="unlockBtn"
              class="secondary"
              title="Unlock editing and local upload with credentials"
            >
              üîí
            </button>
            <button
              id="uploadBtn"
              class="secondary"
              title="Upload a local image (requires unlock)"
              disabled
            >
              üì§
            </button>
            <button
              id="publishBtn"
              class="secondary"
              title="Send current image to API (requires ?id=...)"
              style="display:none;"
            >
              üì®
            </button>
          </div>
        </div>

        <div id="apiError"></div>

        <div class="hint-card">
          <div class="hint-header">
            <div class="hint-title">Quick guide</div>
            <div class="hint-badge">Workflow</div>
          </div>
          <ul class="hint-list">
            <li>
              <span class="hint-icon">1Ô∏è‚É£</span>
              <span>
                <span class="hint-text-strong">Load an image</span><br />
                Call this page with <span class="hint-sub">?src=&lt;image-url&gt;</span>.
              </span>
            </li>
            <li>
              <span class="hint-icon">2Ô∏è‚É£</span>
              <span>
                <span class="hint-text-strong">Inpainting (‚úèÔ∏è + ‚óé)</span><br />
                Use the brush to reveal the areas you want the AI to change. Dark areas are protected.
              </span>
            </li>
            <li>
              <span class="hint-icon">3Ô∏è‚É£</span>
              <span>
                <span class="hint-text-strong">Outpainting (‚õ∂)</span><br />
                Shrinks the image and lets the AI extend the borders with smooth transitions. The brush is disabled in this mode.
              </span>
            </li>
            <li>
              <span class="hint-icon">4Ô∏è‚É£</span>
              <span>
                <span class="hint-text-strong">View mode (üï∂)</span><br />
                Hides the mask overlay. If the image origin is not allowed, view mode is forced until you unlock.
              </span>
            </li>
          </ul>
        </div>
      </div>

      <input
        id="fileInput"
        type="file"
        accept="image/png,image/jpeg,image/webp,image/gif,image/bmp"
        style="display:none;"
      />

      <script>
        const CANVAS_SIZE = 1024;
        const OUTPAINT_SCALE = 0.8;
        const OUTPAINT_OVERLAP = 32;

        const canvasArea = document.getElementById("canvasArea");
        const imageCanvas = document.getElementById("imageCanvas");
        const maskCanvas = document.getElementById("maskCanvas");
        const cursorCanvas = document.getElementById("cursorCanvas");
        const overlayHint = document.getElementById("overlayHint");
        const controlsEl = document.getElementById("controls");
        const promptInput = document.getElementById("prompt");
        const editBtn = document.getElementById("editBtn");
        const modeBtn = document.getElementById("modeBtn");
        const outBtn = document.getElementById("outBtn");
        const viewBtn = document.getElementById("viewBtn");
        const resetBtn = document.getElementById("resetBtn");
        const downloadBtn = document.getElementById("downloadBtn");
        const unlockBtn = document.getElementById("unlockBtn");
        const uploadBtn = document.getElementById("uploadBtn");
        const fileInput = document.getElementById("fileInput");
        const publishBtn = document.getElementById("publishBtn");
        const statusEl = document.getElementById("status");
        const publishNotice = document.getElementById("publishNotice");
        const apiErrorEl = document.getElementById("apiError");
        const brushSizeSlider = document.getElementById("brushSize");
        const brushSizeLabel = document.getElementById("brushSizeLabel");
        const engineSelect = document.getElementById("engineSelect");

        const imgCtx = imageCanvas.getContext("2d");
        const maskCtx = maskCanvas.getContext("2d");
        const cursorCtx = cursorCanvas.getContext("2d");

        let imageLoaded = false;
        let drawing = false;
        let brushSize = parseInt(brushSizeSlider.value, 10) || 25;

        let drawOffsetX = 0;
        let drawOffsetY = 0;
        let drawWidth = 0;
        let drawHeight = 0;

        let originalImageSrc = null;
        let workingImageSrc = null;
        let maskMode = "erase";
        let outpaintMode = false;

        let hostsWhitelist = [];
        let originHost = null;
        let configLoaded = false;
        let supportsUnlock = false;

        let authToken = "";
        let tokenValid = false;

        let allowEdit = false;

        let callbackId = null;

        let viewModeEnabled = false;
        let viewModeForced = false;

        /********************************************************************
         * functionSignature: setPublishNotice(text, isError)
         * purpose: Shows a small publish status badge.
         ********************************************************************/
        function setPublishNotice(text, isError) {
          if (!text) {
            publishNotice.style.display = "none";
            return;
          }
          publishNotice.textContent = text;
          publishNotice.style.display = "inline";
          if (isError) {
            publishNotice.style.borderColor = "rgba(255, 80, 80, 0.5)";
            publishNotice.style.background = "rgba(255, 80, 80, 0.12)";
            publishNotice.style.color = "#ffd2d2";
          } else {
            publishNotice.style.borderColor = "rgba(0, 170, 255, 0.35)";
            publishNotice.style.background = "rgba(0, 170, 255, 0.09)";
            publishNotice.style.color = "#9ddcff";
          }
        }

        /********************************************************************
         * functionSignature: setApiError(text)
         * purpose: Displays API errors on the page.
         ********************************************************************/
        function setApiError(text) {
          const t = String(text || "").trim();
          if (!t) {
            apiErrorEl.style.display = "none";
            apiErrorEl.textContent = "";
            return;
          }
          apiErrorEl.textContent = t;
          apiErrorEl.style.display = "block";
        }

        /********************************************************************
         * functionSignature: clearApiError()
         * purpose: Clears the API error box.
         ********************************************************************/
        function clearApiError() {
          setApiError("");
        }

        /********************************************************************
         * functionSignature: setWorkingImageSrc(src)
         * purpose: Stores the current working image state source (last committed).
         ********************************************************************/
        function setWorkingImageSrc(src) {
          const s = String(src || "").trim();
          if (!s) return;
          workingImageSrc = s;
        }

        /********************************************************************
         * functionSignature: initCanvases()
         * purpose: Initializes all canvases to the fixed tool size.
         ********************************************************************/
        function initCanvases() {
          imageCanvas.width = CANVAS_SIZE;
          imageCanvas.height = CANVAS_SIZE;
          maskCanvas.width = CANVAS_SIZE;
          maskCanvas.height = CANVAS_SIZE;
          cursorCanvas.width = CANVAS_SIZE;
          cursorCanvas.height = CANVAS_SIZE;
        }

        /********************************************************************
         * functionSignature: updateBrushLabel()
         * purpose: Updates the brush size label.
         ********************************************************************/
        function updateBrushLabel() {
          brushSizeLabel.textContent = `${brushSize} px`;
        }

        /********************************************************************
         * functionSignature: handleBrushSizeInput()
         * purpose: Tracks brush size changes.
         ********************************************************************/
        function handleBrushSizeInput() {
          brushSize = parseInt(brushSizeSlider.value, 10) || 25;
          updateBrushLabel();
        }

        /********************************************************************
         * functionSignature: updateMaskModeButton()
         * purpose: Updates the mask mode button icon/tooltip.
         ********************************************************************/
        function updateMaskModeButton() {
          if (maskMode === "erase") {
            modeBtn.title = "Mask mode: reveal areas to be edited";
            modeBtn.textContent = "‚óé";
          } else {
            modeBtn.title = "Mask mode: protect areas (do not edit)";
            modeBtn.textContent = "‚óâ";
          }
        }

        /********************************************************************
         * functionSignature: updateOutpaintButton()
         * purpose: Updates the outpaint button icon/tooltip.
         ********************************************************************/
        function updateOutpaintButton() {
          if (outpaintMode) {
            outBtn.textContent = "‚õ∂";
            outBtn.title =
              "Image mode: outpainting (image shrinks, borders are extended by the AI, brush disabled)";
          } else {
            outBtn.textContent = "‚ñ£";
            outBtn.title =
              "Image mode: inpainting (only within the original image, brush enabled)";
          }
          applyMaskInteractivity();
        }

        /********************************************************************
         * functionSignature: getIsTrustedHost()
         * purpose: Returns true if the origin host is in the host whitelist.
         ********************************************************************/
        function getIsTrustedHost() {
          if (!originHost) return false;
          const low = String(originHost || "").toLowerCase();
          return (hostsWhitelist || [])
            .map((h) => String(h || "").toLowerCase())
            .includes(low);
        }

        /********************************************************************
         * functionSignature: getPreferredViewMode()
         * purpose: Reads view mode preference from session storage.
         ********************************************************************/
        function getPreferredViewMode() {
          const raw = String(
            window.sessionStorage.getItem("inpaintViewMode") || ""
          ).trim();
          return raw === "1";
        }

        /********************************************************************
         * functionSignature: setPreferredViewMode(enabled)
         * purpose: Persists view mode preference to session storage.
         ********************************************************************/
        function setPreferredViewMode(enabled) {
          window.sessionStorage.setItem("inpaintViewMode", enabled ? "1" : "0");
        }

        /********************************************************************
         * functionSignature: applyViewModeUi()
         * purpose: Applies view mode settings (mask visibility and UI).
         ********************************************************************/
        function applyViewModeUi() {
          if (viewModeEnabled) {
            maskCanvas.style.opacity = "0";
            cursorCanvas.style.opacity = "0";
            viewBtn.textContent = "üëÅ";
            viewBtn.title = "View mode enabled (mask hidden). Click to show mask.";
          } else {
            maskCanvas.style.opacity = "0.6";
            cursorCanvas.style.opacity = "1";
            viewBtn.textContent = "üï∂";
            viewBtn.title = "View mode disabled (mask visible). Click to hide mask.";
          }
          applyMaskInteractivity();
        }

        /********************************************************************
         * functionSignature: setViewMode(enabled, forced)
         * purpose: Sets view mode and optionally locks it.
         ********************************************************************/
        function setViewMode(enabled, forced) {
          viewModeEnabled = !!enabled;
          viewModeForced = !!forced;

          viewBtn.disabled = !!viewModeForced || !imageLoaded || !allowEdit;

          applyViewModeUi();
        }

        /********************************************************************
         * functionSignature: applyMaskInteractivity()
         * purpose: Enables/disables painting based on state.
         ********************************************************************/
        function applyMaskInteractivity() {
          const canPaint = !!(imageLoaded && allowEdit && !outpaintMode && !viewModeEnabled);
          maskCanvas.style.pointerEvents = canPaint ? "auto" : "none";
          if (!canPaint) {
            cursorCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
          }
        }

        /********************************************************************
         * functionSignature: recomputeAccessState()
         * purpose: Computes current access and updates UI.
         ********************************************************************/
        function recomputeAccessState() {
          if (!configLoaded) {
            statusEl.textContent = "Loading configuration‚Ä¶";
            editBtn.disabled = true;
            modeBtn.disabled = true;
            outBtn.disabled = true;
            uploadBtn.disabled = true;
            viewBtn.disabled = true;
            updateUnlockButton();
            return;
          }

          const isTrusted = getIsTrustedHost();
          const forcedView = !!(imageLoaded && originHost && !allowEdit && !tokenValid);

          if (!imageLoaded) {
            statusEl.textContent =
              "No image loaded. Unlock to upload a local image, or open with ?src=‚Ä¶";
          } else if (forcedView) {
            statusEl.textContent =
              "Image origin is not allowed ‚Äì view only. Unlock to enable all functions.";
          } else if (!allowEdit && originHost) {
            statusEl.textContent =
              "Editing disabled. Unlock or use an allowed origin.";
          } else if (allowEdit) {
            statusEl.textContent =
              "Editing enabled (" + (tokenValid ? "unlocked" : "allowed") + ").";
          }

          editBtn.disabled = !(allowEdit && imageLoaded);
          modeBtn.disabled = !(allowEdit && imageLoaded) || outpaintMode || viewModeEnabled;
          outBtn.disabled = !(allowEdit && imageLoaded);
          resetBtn.disabled = !imageLoaded;
          downloadBtn.disabled = !imageLoaded;

          uploadBtn.disabled = !(supportsUnlock && tokenValid);

          if (forcedView) {
            setViewMode(true, true);
          } else {
            if (viewModeForced) {
              const pref = getPreferredViewMode();
              setViewMode(pref, false);
            } else {
              viewBtn.disabled = !imageLoaded || !allowEdit;
              applyViewModeUi();
            }
          }

          updateUnlockButton();
        }

        /********************************************************************
         * functionSignature: updateUnlockButton()
         * purpose: Updates the unlock button icon/tooltip.
         ********************************************************************/
        function updateUnlockButton() {
          if (!supportsUnlock) {
            unlockBtn.style.display = "none";
            uploadBtn.style.display = "none";
            return;
          }

          unlockBtn.style.display = "inline-flex";
          uploadBtn.style.display = "inline-flex";

          if (tokenValid) {
            unlockBtn.textContent = "üîì";
            unlockBtn.title = "Unlocked (session). Click to lock this session.";
          } else {
            unlockBtn.textContent = "üîí";
            unlockBtn.title = "Unlock editing and local upload with credentials";
          }
        }

        /********************************************************************
         * functionSignature: getAuthHeaders()
         * purpose: Returns auth headers if token is valid.
         ********************************************************************/
        function getAuthHeaders() {
          const headers = {};
          if (tokenValid && authToken) headers["x-inpaint-auth"] = authToken;
          return headers;
        }

        /********************************************************************
         * functionSignature: refreshCanEditFromServer()
         * purpose: Asks the server whether this origin can be edited.
         ********************************************************************/
        async function refreshCanEditFromServer() {
          if (!originalImageSrc) {
            allowEdit = false;
            recomputeAccessState();
            return;
          }

          try {
            const res = await fetch("/api/can-edit", {
              method: "POST",
              headers: { "Content-Type": "application/json", ...getAuthHeaders() },
              body: JSON.stringify({ origin: originalImageSrc }),
            });

            const data = await res.json().catch(() => ({}));
            allowEdit = !!data.allowed;
          } catch {
            allowEdit = false;
          }

          recomputeAccessState();
        }

        /********************************************************************
         * functionSignature: fetchConfig()
         * purpose: Loads server config (whitelist/engines/capabilities).
         ********************************************************************/
        async function fetchConfig() {
          try {
            const res = await fetch("/api/config");
            if (!res.ok) throw new Error("Config request failed");
            const data = await res.json();

            hostsWhitelist = data.hostsWhitelist || [];
            supportsUnlock = !!data.supportsUnlock;
            configLoaded = true;

            const engines = data.engines || [];
            const defaultEngineId = data.defaultEngineId || null;

            engineSelect.innerHTML = "";

            if (!engines.length) {
              const opt = document.createElement("option");
              opt.value = "";
              opt.textContent = "No engines configured";
              engineSelect.appendChild(opt);
              engineSelect.disabled = true;
            } else {
              for (const e of engines) {
                const opt = document.createElement("option");
                opt.value = e.id;
                opt.textContent = e.label || e.id;
                engineSelect.appendChild(opt);
              }
              engineSelect.disabled = false;
              if (defaultEngineId) engineSelect.value = defaultEngineId;
            }

            recomputeAccessState();
          } catch (e) {
            engineSelect.innerHTML = "";
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "Config error";
            engineSelect.appendChild(opt);
            engineSelect.disabled = true;
            statusEl.textContent = "Error while loading configuration.";
            setApiError("Config error: " + String((e && e.message) || e));
          }
        }

        /********************************************************************
         * functionSignature: validateTokenFromSession()
         * purpose: Loads token from session storage and validates it.
         ********************************************************************/
        async function validateTokenFromSession() {
          const t = String(
            window.sessionStorage.getItem("inpaintAuthToken") || ""
          ).trim();
          authToken = t;

          if (!t) {
            tokenValid = false;
            updateUnlockButton();
            return false;
          }

          try {
            const res = await fetch("/api/validate-token", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "x-inpaint-auth": t,
              },
              body: "{}",
            });

            const data = await res.json().catch(() => ({}));
            tokenValid = !!data.valid;

            if (!tokenValid) {
              window.sessionStorage.removeItem("inpaintAuthToken");
              authToken = "";
            }

            updateUnlockButton();
            return tokenValid;
          } catch {
            tokenValid = false;
            updateUnlockButton();
            return false;
          }
        }

        /********************************************************************
         * functionSignature: lockSession()
         * purpose: Clears the current auth session token.
         ********************************************************************/
        function lockSession() {
          window.sessionStorage.removeItem("inpaintAuthToken");
          authToken = "";
          tokenValid = false;
          updateUnlockButton();
          refreshCanEditFromServer();
        }

        /********************************************************************
         * functionSignature: unlockWithCredentials()
         * purpose: Prompts for username/password and requests a token.
         ********************************************************************/
        async function unlockWithCredentials() {
          if (!supportsUnlock) return false;

          clearApiError();

          if (tokenValid) {
            const ok = window.confirm("Lock this session (remove unlock token)?");
            if (ok) lockSession();
            return tokenValid;
          }

          const username = window.prompt("Username:");
          if (!username) return false;

          const password = window.prompt("Password:");
          if (!password) return false;

          try {
            const res = await fetch("/api/unlock", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ username, password }),
            });

            const data = await res.json().catch(() => ({}));

            if (!res.ok) {
              tokenValid = false;
              updateUnlockButton();
              setApiError(
                "Unlock failed: " + String(data.error || "invalid_credentials")
              );
              return false;
            }

            const token = String(data.token || "").trim();
            if (!token) {
              tokenValid = false;
              updateUnlockButton();
              setApiError("Unlock failed: no token returned.");
              return false;
            }

            window.sessionStorage.setItem("inpaintAuthToken", token);
            await validateTokenFromSession();
            await refreshCanEditFromServer();
            return tokenValid;
          } catch (e) {
            tokenValid = false;
            updateUnlockButton();
            setApiError("Unlock error: " + String((e && e.message) || e));
            return false;
          }
        }

        /********************************************************************
         * functionSignature: uploadLocalFile(file)
         * purpose: Uploads a local image to /results (requires unlock).
         ********************************************************************/
        async function uploadLocalFile(file) {
          if (!file) return;

          clearApiError();

          if (!tokenValid) {
            const ok = await unlockWithCredentials();
            if (!ok) return;
          }

          const fd = new FormData();
          fd.append("image", file, file.name || "upload.png");

          statusEl.textContent = "Uploading‚Ä¶";
          uploadBtn.disabled = true;

          try {
            const res = await fetch("/api/upload-local", {
              method: "POST",
              headers: { ...getAuthHeaders() },
              body: fd,
            });

            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              throw new Error(String(data.error || "upload_failed"));
            }

            const url = data && data.url ? data.url : "";
            if (!url) throw new Error("upload_returned_no_url");

            const abs = new URL(url, window.location.origin).toString();

            originalImageSrc = abs;
            setWorkingImageSrc(abs);
            outpaintMode = false;
            updateOutpaintButton();

            try {
              const u = new URL(abs);
              originHost = u.host;
            } catch {
              originHost = null;
            }

            statusEl.textContent = "Loading uploaded image‚Ä¶";
            loadImageFromSrc(abs, { scaleMode: "fit", maskMode: "fullBlack" });
            await refreshCanEditFromServer();
          } catch (e) {
            statusEl.textContent =
              "Upload error: " + String((e && e.message) || e);
            setApiError(statusEl.textContent);
          } finally {
            recomputeAccessState();
          }
        }

        /********************************************************************
         * functionSignature: setMaskFullBlack()
         * purpose: Resets the mask to full black (protect everything).
         ********************************************************************/
        function setMaskFullBlack() {
          maskCtx.setTransform(1, 0, 0, 1, 0, 0);
          maskCtx.globalCompositeOperation = "source-over";
          maskCtx.fillStyle = "rgba(0,0,0,1)";
          maskCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
          maskCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
          maskCtx.beginPath();
        }

        /********************************************************************
         * functionSignature: setMaskFullTransparent()
         * purpose: Clears the mask fully (edit everything).
         ********************************************************************/
        function setMaskFullTransparent() {
          maskCtx.setTransform(1, 0, 0, 1, 0, 0);
          maskCtx.globalCompositeOperation = "source-over";
          maskCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
          maskCtx.beginPath();
        }

        
        /********************************************************************
         * functionSignature: setMaskForOutpaintDefault()
         * purpose: Initializes mask for outpainting by protecting the inner
         *          portion of the drawn image and leaving border + overlap
         *          transparent (editable) for seamless blending.
         ********************************************************************/
        function setMaskForOutpaintDefault() {
          const overlap = Math.max(0, Math.floor(OUTPAINT_OVERLAP || 0));

          const x0 = Math.max(0, Math.floor(drawOffsetX + overlap));
          const y0 = Math.max(0, Math.floor(drawOffsetY + overlap));
          const x1 = Math.min(CANVAS_SIZE, Math.ceil(drawOffsetX + drawWidth - overlap));
          const y1 = Math.min(CANVAS_SIZE, Math.ceil(drawOffsetY + drawHeight - overlap));

          const w = Math.max(0, x1 - x0);
          const h = Math.max(0, y1 - y0);

          maskCtx.setTransform(1, 0, 0, 1, 0, 0);
          maskCtx.globalCompositeOperation = "source-over";

          maskCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

          if (w > 0 && h > 0) {
            maskCtx.fillStyle = "rgba(0,0,0,1)";
            maskCtx.fillRect(x0, y0, w, h);
          }

          maskCtx.beginPath();
        }

/********************************************************************
         * functionSignature: loadImageFromSrc(src, options)
         * purpose: Loads an image and draws it into the fixed canvas.
         ********************************************************************/
        function loadImageFromSrc(src, options = {}) {
          const { scaleMode = "fit", maskMode = "fullBlack" } = options;

          const img = new Image();

          img.onload = () => {
            initCanvases();

            imgCtx.setTransform(1, 0, 0, 1, 0, 0);
            imgCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            imgCtx.fillStyle = "black";
            imgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            const baseScale = Math.min(
              CANVAS_SIZE / img.width,
              CANVAS_SIZE / img.height
            );

            let scale = baseScale;
            if (scaleMode === "shrinkForOutpaint") {
              scale = baseScale * OUTPAINT_SCALE;
            }

            drawWidth = img.width * scale;
            drawHeight = img.height * scale;
            drawOffsetX = (CANVAS_SIZE - drawWidth) / 2;
            drawOffsetY = (CANVAS_SIZE - drawHeight) / 2;

            imgCtx.drawImage(
              img,
              0,
              0,
              img.width,
              img.height,
              drawOffsetX,
              drawOffsetY,
              drawWidth,
              drawHeight
            );

                        if (maskMode === "fullBlack") setMaskFullBlack();
            else if (maskMode === "fullTransparent") setMaskFullTransparent();
            else if (maskMode === "outpaintDefault") setMaskForOutpaintDefault();
            else setMaskFullBlack();
overlayHint.classList.add("hidden");
            controlsEl.style.display = "flex";

            imageLoaded = true;

            const pref = getPreferredViewMode();
            if (!viewModeForced) viewModeEnabled = pref;

            refreshCanEditFromServer();
          };

          img.onerror = () => {
            statusEl.textContent =
              "Error loading image (CORS / same-origin restrictions?).";
            setApiError(statusEl.textContent);
          };

          img.crossOrigin = "anonymous";
          img.src = src;
        }

        /********************************************************************
         * functionSignature: getCanvasPos(evt)
         * purpose: Converts a mouse/touch event into canvas coordinates.
         ********************************************************************/
        function getCanvasPos(evt) {
          const rect = maskCanvas.getBoundingClientRect();
          return {
            x: ((evt.clientX - rect.left) / rect.width) * maskCanvas.width,
            y: ((evt.clientY - rect.top) / rect.height) * maskCanvas.height,
          };
        }

        /********************************************************************
         * functionSignature: drawCursor(evt)
         * purpose: Draws the circular brush cursor.
         ********************************************************************/
        function drawCursor(evt) {
          if (!imageLoaded || outpaintMode || viewModeEnabled || !allowEdit) {
            cursorCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            return;
          }
          const pos = getCanvasPos(evt);
          cursorCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
          cursorCtx.beginPath();
          cursorCtx.arc(pos.x, pos.y, brushSize, 0, Math.PI * 2);
          cursorCtx.strokeStyle = "rgba(255,255,255,0.9)";
          cursorCtx.lineWidth = 1;
          cursorCtx.stroke();
        }

        /********************************************************************
         * functionSignature: clearCursor()
         * purpose: Clears the cursor canvas.
         ********************************************************************/
        function clearCursor() {
          cursorCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }

        /********************************************************************
         * functionSignature: startDraw(evt)
         * purpose: Starts drawing on the mask.
         ********************************************************************/
        function startDraw(evt) {
          if (!imageLoaded) return;
          if (!allowEdit) return;
          if (outpaintMode) return;
          if (viewModeEnabled) return;

          drawing = true;
          draw(evt);
        }

        /********************************************************************
         * functionSignature: stopDraw()
         * purpose: Stops drawing on the mask.
         ********************************************************************/
        function stopDraw() {
          drawing = false;
          maskCtx.beginPath();
        }

        /********************************************************************
         * functionSignature: draw(evt)
         * purpose: Draws the current brush stroke on the mask.
         ********************************************************************/
        function draw(evt) {
          if (!drawing) return;

          const pos = getCanvasPos(evt);

          if (maskMode === "erase") {
            maskCtx.globalCompositeOperation = "destination-out";
            maskCtx.fillStyle = "rgba(0,0,0,1)";
          } else {
            maskCtx.globalCompositeOperation = "source-over";
            maskCtx.fillStyle = "rgba(0,0,0,1)";
          }

          maskCtx.beginPath();
          maskCtx.arc(pos.x, pos.y, brushSize, 0, Math.PI * 2);
          maskCtx.fill();

          drawCursor(evt);
        }

        /********************************************************************
         * functionSignature: handleModeBtnClick()
         * purpose: Toggles between erase/protect mask modes.
         ********************************************************************/
        function handleModeBtnClick() {
          if (!allowEdit || !imageLoaded) return;
          maskMode = maskMode === "erase" ? "protect" : "erase";
          updateMaskModeButton();
        }

        /********************************************************************
         * functionSignature: handleOutBtnClick()
         * purpose: Toggles between inpaint and outpaint modes.
         ********************************************************************/
        function handleOutBtnClick() {
          if (!imageLoaded) return;
          if (!allowEdit) return;

          outpaintMode = !outpaintMode;
          updateOutpaintButton();

          if (outpaintMode) {
            const base = imageCanvas.toDataURL("image/png");
            loadImageFromSrc(base, { scaleMode: "shrinkForOutpaint", maskMode: "outpaintDefault" });
            statusEl.textContent = "Outpainting mode enabled.";
          } else {
            const back = workingImageSrc || originalImageSrc;
            if (back) {
              loadImageFromSrc(back, { scaleMode: "fit", maskMode: "fullBlack" });
            }
            statusEl.textContent = "Inpainting mode enabled.";
          }
        }

        /********************************************************************
         * functionSignature: handleViewBtnClick()
         * purpose: Toggles view mode (mask overlay visible/hidden).
         ********************************************************************/
        function handleViewBtnClick() {
          if (!imageLoaded) return;
          if (!allowEdit) return;
          if (viewModeForced) return;

          viewModeEnabled = !viewModeEnabled;
          setPreferredViewMode(viewModeEnabled);
          applyViewModeUi();
          recomputeAccessState();
        }

        /********************************************************************
         * functionSignature: handleMaskMouseDown(e)
         * purpose: Starts drawing via mouse.
         ********************************************************************/
        function handleMaskMouseDown(e) {
          startDraw(e);
        }

        /********************************************************************
         * functionSignature: handleMaskMouseMove(e)
         * purpose: Draws or updates cursor via mouse.
         ********************************************************************/
        function handleMaskMouseMove(e) {
          if (drawing) draw(e);
          else drawCursor(e);
        }

        /********************************************************************
         * functionSignature: handleMaskMouseLeave()
         * purpose: Clears cursor when leaving canvas.
         ********************************************************************/
        function handleMaskMouseLeave() {
          clearCursor();
        }

        /********************************************************************
         * functionSignature: handleTouchStart(e)
         * purpose: Starts drawing via touch.
         ********************************************************************/
        function handleTouchStart(e) {
          e.preventDefault();
          if (!e.touches || !e.touches[0]) return;
          startDraw(e.touches[0]);
        }

        /********************************************************************
         * functionSignature: handleTouchEnd(e)
         * purpose: Stops drawing via touch.
         ********************************************************************/
        function handleTouchEnd(e) {
          e.preventDefault();
          stopDraw();
          clearCursor();
        }

        /********************************************************************
         * functionSignature: handleTouchMove(e)
         * purpose: Draws or updates cursor via touch.
         ********************************************************************/
        function handleTouchMove(e) {
          e.preventDefault();
          if (!e.touches || !e.touches[0]) return;
          if (drawing) draw(e.touches[0]);
          else drawCursor(e.touches[0]);
        }

        /********************************************************************
         * functionSignature: handleResetClick()
         * purpose: Resets the view back to the original image.
         ********************************************************************/
        function handleResetClick() {
          setPublishNotice("", false);
          clearApiError();

          if (!originalImageSrc) {
            statusEl.textContent = "No original image available.";
            return;
          }

          outpaintMode = false;
          updateOutpaintButton();

          setWorkingImageSrc(originalImageSrc);
          loadImageFromSrc(originalImageSrc, { scaleMode: "fit", maskMode: "fullBlack" });
          statusEl.textContent = "Reset back to the original image.";
        }

        /********************************************************************
         * functionSignature: handleDownloadClick()
         * purpose: Downloads the current canvas content as PNG.
         ********************************************************************/
        function handleDownloadClick() {
          clearApiError();

          if (!imageLoaded) return;

          const cropCanvas = document.createElement("canvas");
          cropCanvas.width = drawWidth;
          cropCanvas.height = drawHeight;
          const cropCtx = cropCanvas.getContext("2d");

          cropCtx.drawImage(
            imageCanvas,
            drawOffsetX,
            drawOffsetY,
            drawWidth,
            drawHeight,
            0,
            0,
            drawWidth,
            drawHeight
          );

          cropCanvas.toBlob((blob) => {
            if (!blob) return;
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "image.png";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, "image/png");
        }

        /********************************************************************
         * functionSignature: handleUnlockClick()
         * purpose: Unlocks/locks the tool session.
         ********************************************************************/
        async function handleUnlockClick() {
          await unlockWithCredentials();
        }

        /********************************************************************
         * functionSignature: handleUploadClick()
         * purpose: Opens the file selector after unlock.
         ********************************************************************/
        async function handleUploadClick() {
          if (!supportsUnlock) return;
          if (!tokenValid) {
            const ok = await unlockWithCredentials();
            if (!ok) return;
          }
          fileInput.click();
        }

        /********************************************************************
         * functionSignature: handleFileInputChange(e)
         * purpose: Starts uploading the selected file.
         ********************************************************************/
        async function handleFileInputChange(e) {
          const f = e.target.files && e.target.files[0];
          e.target.value = "";
          if (!f) return;
          await uploadLocalFile(f);
        }

        /********************************************************************
         * functionSignature: handleDragOver(e)
         * purpose: Enables drag/drop when unlock is supported.
         ********************************************************************/
        function handleDragOver(e) {
          if (!supportsUnlock) return;
          e.preventDefault();
        }

        /********************************************************************
         * functionSignature: handleDrop(e)
         * purpose: Handles drag/drop upload.
         ********************************************************************/
        async function handleDrop(e) {
          if (!supportsUnlock) return;
          e.preventDefault();

          const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
          if (!f) return;

          await uploadLocalFile(f);
        }

        /********************************************************************
         * functionSignature: storeCurrentViewAndGetUrl()
         * purpose: Stores the current image view as /results URL.
         ********************************************************************/
        async function storeCurrentViewAndGetUrl() {
          if (!imageLoaded) throw new Error("No image loaded.");

          const cropCanvas = document.createElement("canvas");
          cropCanvas.width = drawWidth;
          cropCanvas.height = drawHeight;
          const cropCtx = cropCanvas.getContext("2d");

          cropCtx.drawImage(
            imageCanvas,
            drawOffsetX,
            drawOffsetY,
            drawWidth,
            drawHeight,
            0,
            0,
            drawWidth,
            drawHeight
          );

          const blob = await new Promise((resolve) =>
            cropCanvas.toBlob(resolve, "image/png")
          );
          if (!blob) throw new Error("Could not create PNG blob.");

          const fd = new FormData();
          fd.append("image", blob, "current.png");

          const res = await fetch("/api/store", { method: "POST", body: fd });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error(String(data.error || "store_failed"));

          if (!data || !data.url) throw new Error("store_returned_no_url");
          return new URL(data.url, window.location.origin).toString();
        }

        /********************************************************************
         * functionSignature: handlePublishClick()
         * purpose: Publishes the current image to callback API.
         ********************************************************************/
        async function handlePublishClick() {
          if (!callbackId) return;
          if (!originalImageSrc) {
            statusEl.textContent = "No original src available.";
            return;
          }

          clearApiError();
          setPublishNotice("‚è≥ Sending‚Ä¶", false);

          publishBtn.disabled = true;
          editBtn.disabled = true;
          resetBtn.disabled = true;
          downloadBtn.disabled = true;

          try {
            statusEl.textContent = "Storing current view‚Ä¶";
            const editedAbsUrl = await storeCurrentViewAndGetUrl();

            statusEl.textContent = "Publishing to API‚Ä¶";
            const res = await fetch("/api/publish", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                id: callbackId,
                originalUrl: originalImageSrc,
                editedUrl: editedAbsUrl,
              }),
            });

            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              throw new Error(String(data.error || "publish_failed"));
            }

            setPublishNotice("‚úÖ Sent", false);
            statusEl.textContent = "Published ‚úÖ";
          } catch (e) {
            setPublishNotice("‚ùå Send failed", true);
            statusEl.textContent = "Publish error: " + String((e && e.message) || e);
            setApiError(statusEl.textContent);
          } finally {
            publishBtn.disabled = !callbackId;
            editBtn.disabled = false;
            resetBtn.disabled = false;
            downloadBtn.disabled = false;
            recomputeAccessState();
          }
        }

        /********************************************************************
         * functionSignature: handleEditClick()
         * purpose: Sends image+mask to the edit API.
         ********************************************************************/
        async function handleEditClick() {
          setPublishNotice("", false);
          clearApiError();

          if (!imageLoaded || !allowEdit) {
            setApiError("Editing is not allowed for this image origin. Unlock to enable.");
            return;
          }

          const prompt = promptInput.value.trim();
          if (!prompt) {
            setApiError("Please enter a prompt.");
            return;
          }

          editBtn.disabled = true;
          resetBtn.disabled = true;
          downloadBtn.disabled = true;
          viewBtn.disabled = true;
          if (callbackId) publishBtn.disabled = true;

          statusEl.textContent = "Sending image‚Ä¶";

          try {
            const imageBlob = await new Promise((resolve) =>
              imageCanvas.toBlob(resolve, "image/png")
            );
            const maskBlob = await new Promise((resolve) =>
              maskCanvas.toBlob(resolve, "image/png")
            );

            const formData = new FormData();
            formData.append("prompt", prompt);
            formData.append("image", imageBlob, "image.png");
            formData.append("mask", maskBlob, "mask.png");

            if (originalImageSrc) {
              formData.append("origin", originalImageSrc);
            }

            if (engineSelect.value) {
              formData.append("engineId", engineSelect.value);
            }

            const res = await fetch("/api/edit", {
              method: "POST",
              headers: { ...getAuthHeaders() },
              body: formData,
            });

            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              const msg = String(data.message || data.error || "edit_failed");
              throw new Error(msg);
            }

            statusEl.textContent = "Response received‚Ä¶";

            const editedImg = new Image();
            editedImg.onload = () => {
              const tmpCanvas = document.createElement("canvas");
              tmpCanvas.width = CANVAS_SIZE;
              tmpCanvas.height = CANVAS_SIZE;
              const tmpCtx = tmpCanvas.getContext("2d");
              tmpCtx.drawImage(editedImg, 0, 0, CANVAS_SIZE, CANVAS_SIZE);

              if (outpaintMode) {
                const nextDataUrl = tmpCanvas.toDataURL("image/png");
                setWorkingImageSrc(nextDataUrl);
                statusEl.textContent = "Done (outpainting). Result is shown in the canvas.";

                outpaintMode = false;
                updateOutpaintButton();

                loadImageFromSrc(nextDataUrl, { scaleMode: "fit", maskMode: "fullBlack" });
              } else {
                const cropCanvas = document.createElement("canvas");
                cropCanvas.width = drawWidth;
                cropCanvas.height = drawHeight;
                const cropCtx = cropCanvas.getContext("2d");

                cropCtx.drawImage(
                  tmpCanvas,
                  drawOffsetX,
                  drawOffsetY,
                  drawWidth,
                  drawHeight,
                  0,
                  0,
                  drawWidth,
                  drawHeight
                );

                const nextDataUrl = cropCanvas.toDataURL("image/png");
                setWorkingImageSrc(nextDataUrl);
                statusEl.textContent = "Done (inpainting). Result is shown in the canvas.";

                loadImageFromSrc(nextDataUrl, { scaleMode: "fit", maskMode: "fullBlack" });
              }
            };

            editedImg.onerror = () => {
              statusEl.textContent = "Error loading AI image.";
              setApiError(statusEl.textContent);
            };

            editedImg.src = data.url;
          } catch (err) {
            statusEl.textContent = "Error: " + String(err && err.message ? err.message : err);
            setApiError(statusEl.textContent);
          } finally {
            editBtn.disabled = false;
            resetBtn.disabled = false;
            downloadBtn.disabled = false;
            viewBtn.disabled = false;
            publishBtn.disabled = !callbackId;
            refreshCanEditFromServer();
          }
        }

        /********************************************************************
         * functionSignature: loadFromQueryUrl()
         * purpose: Reads image source and callback id from URL params.
         ********************************************************************/
        function loadFromQueryUrl() {
          const params = new URLSearchParams(window.location.search);
          const imageUrl = params.get("image") || params.get("src") || params.get("url");

          callbackId = params.get("id") || null;

          if (callbackId) {
            publishBtn.style.display = "inline-flex";
            publishBtn.disabled = false;
          }

          if (!imageUrl) {
            statusEl.textContent =
              "No image URL found. Unlock to upload a local image, or call this page with ?src=‚Ä¶";
            overlayHint.classList.remove("hidden");
            controlsEl.style.display = "flex";
            imageLoaded = false;
            allowEdit = false;
            setViewMode(true, true);
            recomputeAccessState();
            return;
          }

          originalImageSrc = imageUrl;
          setWorkingImageSrc(imageUrl);
          outpaintMode = false;
          updateOutpaintButton();

          try {
            const u = new URL(imageUrl);
            originHost = u.host;
          } catch {
            originHost = null;
          }

          statusEl.textContent = "Loading image from URL‚Ä¶";
          loadImageFromSrc(imageUrl, { scaleMode: "fit", maskMode: "fullBlack" });
        }

        /********************************************************************
         * functionSignature: bindEvents()
         * purpose: Binds all UI event handlers.
         ********************************************************************/
        function bindEvents() {
          brushSizeSlider.addEventListener("input", handleBrushSizeInput);

          modeBtn.addEventListener("click", handleModeBtnClick);
          outBtn.addEventListener("click", handleOutBtnClick);
          viewBtn.addEventListener("click", handleViewBtnClick);

          maskCanvas.addEventListener("mousedown", handleMaskMouseDown);
          window.addEventListener("mouseup", stopDraw);
          maskCanvas.addEventListener("mousemove", handleMaskMouseMove);
          maskCanvas.addEventListener("mouseleave", handleMaskMouseLeave);

          maskCanvas.addEventListener("touchstart", handleTouchStart);
          maskCanvas.addEventListener("touchend", handleTouchEnd);
          maskCanvas.addEventListener("touchmove", handleTouchMove);

          resetBtn.addEventListener("click", handleResetClick);
          downloadBtn.addEventListener("click", handleDownloadClick);

          unlockBtn.addEventListener("click", handleUnlockClick);
          uploadBtn.addEventListener("click", handleUploadClick);
          fileInput.addEventListener("change", handleFileInputChange);

          canvasArea.addEventListener("dragover", handleDragOver);
          canvasArea.addEventListener("drop", handleDrop);

          publishBtn.addEventListener("click", handlePublishClick);
          editBtn.addEventListener("click", handleEditClick);
        }

        /********************************************************************
         * functionSignature: bootstrap()
         * purpose: Initializes UI, loads config, restores auth, loads image.
         ********************************************************************/
        async function bootstrap() {
          initCanvases();
          updateBrushLabel();
          updateMaskModeButton();
          updateOutpaintButton();

          bindEvents();

          viewModeEnabled = getPreferredViewMode();
          applyViewModeUi();

          await fetchConfig();
          await validateTokenFromSession();
          loadFromQueryUrl();
        }

        bootstrap();
      </script>
    </div>
  </body>
</html>
